"""Human-readable equation rendering for SysIdentPy models.

This module provides non-breaking utilities to render the final model equation
for models using non-polynomial basis functions (e.g., Fourier, Legendre).

Design principles
-----------------
- Do not change any estimator/backend class.
- Work with available model attributes: `basis_function`, `xlag`, `ylag`,
  `n_inputs`, `pivv`, `theta`, and `model_type` when present.
- For Polynomial models, delegate to `utils.display_results.results` to
  preserve existing behavior.
- For non-polynomial models, reconstruct feature names in the same order as
  the respective basis function builds its regressor matrix, then map the
  selected column indices (`pivv`) to names and pair with `theta`.

Public API
----------
- results_general(model, input_names=None, output_name="y") -> List[EquationItem]
- print_equation(model, input_names=None, output_name="y", style="text") -> str

Extendability
-------------
Add a renderer to `RendererRegistry` keyed by the basis function class name.
Each renderer returns the full list of column names in the order generated by
its `fit/transform` method given the model configuration.
"""

from __future__ import annotations

from collections import Counter
from dataclasses import dataclass
from itertools import combinations_with_replacement
from typing import List, Optional, Sequence

import numpy as np

from .lags import _process_ylag
from .display_results import results as _poly_results


@dataclass(frozen=True)
class EquationItem:
    name: str
    coef: float


def _ensure_input_names(
    n_inputs: int, input_names: Optional[Sequence[str]]
) -> List[str]:
    if input_names is None:
        return [f"x{i+1}" for i in range(n_inputs)]
    names = list(input_names)
    if len(names) != n_inputs:
        # pad or trim to match
        names = (names + [f"x{i+1}" for i in range(len(names), n_inputs)])[:n_inputs]
    return names


def _normalize_xlag(xlag, n_inputs: int) -> List[List[int]]:
    """Normalize xlag into a nested list of per-input lag lists.

    Mirrors the ordering in `information_matrix._create_lagged_x`.
    """
    if isinstance(xlag, int):
        return [list(range(1, xlag + 1))] if n_inputs == 1 else [[xlag]]

    # xlag is a list: could be flat or nested
    if n_inputs == 1 and all(isinstance(i, int) for i in xlag):
        return [list(xlag)]

    # nested case: ensure each item is a list
    return [[i] if isinstance(i, int) else list(i) for i in xlag]


def _base_lag_feature_names(
    *, n_inputs: int, xlag, ylag, input_names: Optional[Sequence[str]], output_name: str
) -> List[str]:
    """Names of raw lagged variables in the same order as `lagged_data[:, 1:]`.

    Order: [y(k-1..), ..., then x1(k-..), x2(k-..), ...]
    """
    in_names = _ensure_input_names(n_inputs, input_names)
    ylags = _process_ylag(ylag)
    xlags_nested = _normalize_xlag(xlag, n_inputs)

    names: List[str] = []
    # y lags first
    names.extend([f"{output_name}(k-{lag})" for lag in ylags])

    # inputs
    for i in range(n_inputs):
        xi = in_names[i]
        names.extend([f"{xi}(k-{lag})" for lag in xlags_nested[i]])

    return names


def _legendre_like_names(
    *,
    basis_name: str,
    n_inputs: int,
    xlag,
    ylag,
    degree: int,
    include_bias: bool,
    ensemble: bool,
    input_names: Optional[Sequence[str]],
    output_name: str,
) -> List[str]:
    """Return names for Legendre/Hermite/Laguerre/Bernstein-style classes.

    These classes share the same fit logic:
    - Start from lagged_data[:, 1:] (no constant)
    - For each base column, build degrees 1..degree
    - Optionally prepend a bias column
    - Optionally prepend the original data columns if ensemble=True
    """
    base = _base_lag_feature_names(
        n_inputs=n_inputs,
        xlag=xlag,
        ylag=ylag,
        input_names=input_names,
        output_name=output_name,
    )

    # expansion symbol per basis
    sym = {
        "Legendre": "P",
        "Hermite": "H",
        "HermiteNormalized": "He",
        "Laguerre": "L",
        "Bernstein": "B",
    }.get(basis_name, basis_name)

    exp_names: List[str] = []
    for var in base:
        for d in range(1, degree + 1):
            if sym == "B":
                exp_names.append(f"B{d}({var})")
            else:
                exp_names.append(f"{sym}{d}({var})")

    names: List[str] = []
    if include_bias:
        names.append("1")
    if ensemble:
        names.extend(base)
    names.extend(exp_names)
    return names


def _fourier_names(
    *,
    n_inputs: int,
    xlag,
    ylag,
    degree: int,
    n_harmonics: int,
    ensemble: bool,
    input_names: Optional[Sequence[str]],
    output_name: str,
) -> List[str]:
    """Return column names for Fourier basis.

    Column order in Fourier.fit:
        - If degree > 1: `data` is Polynomial().fit(...)[ :, 1:]
            (monomials without intercept)
    - Else: `data` is lagged_data[max_lag:, 1:] (raw lags)
    - For each `data` column (left-to-right), append cos/sin for h=1..n_harmonics
    - If ensemble=True, prepend the original `data` columns first
    """
    # Build base data column names
    if degree and degree > 1:
        # Name monomials generated by Polynomial.fit over lagged_data
        base = _polynomial_monomial_names(
            n_inputs=n_inputs,
            xlag=xlag,
            ylag=ylag,
            degree=degree,
            input_names=input_names,
            output_name=output_name,
        )
    else:
        base = _base_lag_feature_names(
            n_inputs=n_inputs,
            xlag=xlag,
            ylag=ylag,
            input_names=input_names,
            output_name=output_name,
        )

    names: List[str] = []
    if ensemble:
        names.extend(base)

    for var in base:
        for h in range(1, n_harmonics + 1):
            names.append(f"cos({h}·{var})")
            names.append(f"sin({h}·{var})")
    return names


def _polynomial_monomial_names(
    *,
    n_inputs: int,
    xlag,
    ylag,
    degree: int,
    input_names: Optional[Sequence[str]],
    output_name: str,
) -> List[str]:
    """Recreate monomial names in the order Polynomial.fit would generate.

    This mirrors Polynomial.fit combinations over `lagged_data` columns.
    """
    in_names = _ensure_input_names(n_inputs, input_names)
    ylags = _process_ylag(ylag)
    xlags_nested = _normalize_xlag(xlag, n_inputs)

    # Column 0 is constant 1, then y lags, then x lags in order
    base_cols: List[str] = ["1"]
    base_cols.extend([f"{output_name}(k-{lag})" for lag in ylags])
    for i in range(n_inputs):
        xi = in_names[i]
        base_cols.extend([f"{xi}(k-{lag})" for lag in xlags_nested[i]])

    combos = list(combinations_with_replacement(range(len(base_cols)), degree))

    def idx_row_to_name(idx_row: Sequence[int]) -> str:
        counts = Counter(idx_row)
        parts: List[str] = []
        for idx in sorted(counts.keys()):
            if idx == 0:
                # skip explicit "1" factor
                continue
            var = base_cols[idx]
            exp = counts[idx]
            parts.append(var + (f"^{exp}" if exp > 1 else ""))
        return "".join(parts) if parts else "1"

    names = [idx_row_to_name(row) for row in combos]
    # Drop intercept to mirror Fourier.fit slicing [:, 1:]
    return names[0 + 1 :]



def _is_polynomial_model(model) -> bool:
    bf = getattr(model, "basis_function", None)
    return (
        getattr(bf, "__class__", None) is not None
        and bf.__class__.__name__ == "Polynomial"
    )


def results_general(
    model,
    *,
    input_names: Optional[Sequence[str]] = None,
    output_name: str = "y",
) -> List[EquationItem]:
    """Return list of (feature name, coefficient) for the model's selected terms.

    Behavior:
    - Polynomial basis: delegate to existing `display_results.results` (if available)
      to generate names and use `theta` values.
    - Non-polynomial basis: reconstruct full column name list and map selected
      column indices (`pivv`) to names, zipped with `theta`.
    """
    theta = getattr(model, "theta", None)
    if theta is None:
        return []

    # Normalize theta to 1D float list
    theta_arr = np.array(theta).reshape(-1)
    if theta_arr.size == 0:
        return []

    # Polynomial path: reuse stable behavior
    if _is_polynomial_model(model) and _poly_results is not None:
        final_model = getattr(model, "final_model", None)
        err = getattr(model, "err", None)
        n_terms = getattr(model, "n_terms", theta_arr.size)
        table = _poly_results(
            final_model,
            np.array(theta_arr).reshape(-1, 1),
            err,
            n_terms,
            dtype="sci",
        )
        return [EquationItem(name=row[0], coef=float(row[1])) for row in table]

    # Non-polynomial path
    basis = getattr(model, "basis_function", None)
    if basis is None:
        return []

    # Infer n_inputs (prefer attribute; fallback to xlag structure)
    n_inputs = getattr(model, "n_inputs", None)
    if n_inputs is None:
        # Approximate: single input if xlag is int
        xlag = getattr(model, "xlag", 1)
        n_inputs = 1 if isinstance(xlag, int) else len(xlag)

    xlag = getattr(model, "xlag", 1)
    ylag = getattr(model, "ylag", 1)
    degree = getattr(basis, "degree", 1) or 1
    basis_name = basis.__class__.__name__
    # model_type is not required here for naming
    # Build the full column name list as generated by basis_function.fit
    names: List[str]
    if basis_name == "Fourier":
        n_harm = getattr(basis, "n", 1) or 1
        ensemble = bool(getattr(basis, "ensemble", False))
        names = _fourier_names(
            n_inputs=n_inputs,
            xlag=xlag,
            ylag=ylag,
            degree=degree,
            n_harmonics=n_harm,
            ensemble=ensemble,
            input_names=input_names,
            output_name=output_name,
        )
    elif basis_name in {
        "Legendre",
        "Hermite",
        "HermiteNormalized",
        "Laguerre",
        "Bernstein",
    }:
        include_bias = bool(getattr(basis, "include_bias", True))
        ensemble = bool(getattr(basis, "ensemble", False))
        names = _legendre_like_names(
            basis_name=basis_name,
            n_inputs=n_inputs,
            xlag=xlag,
            ylag=ylag,
            degree=degree,
            include_bias=include_bias,
            ensemble=ensemble,
            input_names=input_names,
            output_name=output_name,
        )
    else:
        # Generic fallback: base lags only
        names = _base_lag_feature_names(
            n_inputs=n_inputs,
            xlag=xlag,
            ylag=ylag,
            input_names=input_names,
            output_name=output_name,
        )

        # If basis has degree attribute and it's >1, append placeholders
        if degree and degree > 1:
            extra: List[str] = [
                f"{var}^{d}" for var in names for d in range(2, degree + 1)
            ]
            names = names + extra

    # Map selected columns via pivv; if not available, assume full model in order
    pivv = getattr(model, "pivv", None)
    if pivv is None:
        # Just pair in order up to min length
        size = min(len(names), theta_arr.size)
        return [
            EquationItem(name=names[i], coef=float(theta_arr[i])) for i in range(size)
        ]

    # Ensure indices are within bounds and map
    items: List[EquationItem] = []
    for i, col_idx in enumerate(np.array(pivv).reshape(-1)[: theta_arr.size]):
        idx = int(col_idx)
        if 0 <= idx < len(names):
            items.append(EquationItem(name=names[idx], coef=float(theta_arr[i])))
        else:
            items.append(EquationItem(name=f"f_{idx}", coef=float(theta_arr[i])))

    return items


def print_equation(
    model,
    *,
    input_names: Optional[Sequence[str]] = None,
    output_name: str = "y",
    style: str = "text",  # "text" or "latex"
    coef_format: str = ".6g",
) -> str:
    """Render the final model as a compact equation string.

    Example (text):
        y(k) = +0.9·cos(1·x1(k-2)) -0.2·y(k-1) + ...
    """
    items = results_general(model, input_names=input_names, output_name=output_name)
    if not items:
        return ""

    def fmt_coef(c: float) -> str:
        s = format(c, coef_format)
        if not s.startswith("-"):
            s = "+" + s
        return s

    lhs = f"{output_name}(k)"
    if style == "latex":
        rhs_terms = [f"{fmt_coef(t.coef)}\\,{t.name}" for t in items]
        rhs = " ".join(rhs_terms)
        return f"{lhs} = {rhs}"
    else:
        rhs_terms = [f"{fmt_coef(t.coef)}·{t.name}" for t in items]
        rhs = " ".join(rhs_terms)
        return f"{lhs} = {rhs}"

"""Human-readable equation rendering for SysIdentPy models.

This module provides non-breaking utilities to render the final model equation
for models using different basis functions (e.g., Polynomial, Fourier, Legendre).

Design principles
-----------------
- Do not change any estimator/backend class.
- Work with available model attributes: `basis_function`, `xlag`, `ylag`,
  `n_inputs`, `pivv`, `theta`, and `model_type` when present.
- Reconstruct feature names in the same order as the respective basis function
    builds its regressor matrix, then map the selected column indices (`pivv`) to
    names and pair with `theta`.

Public API
----------
- results_general(model, input_names=None, output_name="y") -> List[EquationItem]
- format_equation(model, input_names=None, output_name="y", style="text") -> str

Extendability
-------------
Add a renderer to `RendererRegistry` keyed by the basis function class name.
Each renderer returns the full list of column names in the order generated by
its `fit/transform` method given the model configuration.
"""

from __future__ import annotations

from collections import Counter
import warnings
from dataclasses import dataclass
from itertools import combinations_with_replacement
from typing import Callable, Dict, List, Optional, Sequence

import numpy as np

from .lags import _process_ylag


@dataclass(frozen=True)
class EquationItem:
    """Pair name-coefficient used to assemble human readable equations."""

    name: str
    coef: float


def _format_coefficient(
    value: float, *, coef_format: str, leading: bool, first_sign: bool
) -> str:
    """Format a single coefficient with sign logic.

    Parameters
    ----------
    value : float
        Coefficient value.
    coef_format : str
        Format specification passed to format().
    leading : bool
        True if this term is not the first already appended (controls '+').
    first_sign : bool
        Force show '+' on the first positive term when True.
    """
    s = format(value, coef_format)
    if s.startswith("-"):
        return s
    return ("+" + s) if (leading or first_sign) else s


def _ensure_input_names(
    n_inputs: int, input_names: Optional[Sequence[str]]
) -> List[str]:
    if input_names is None:
        return [f"x{i+1}" for i in range(n_inputs)]
    names = list(input_names)
    if len(names) != n_inputs:
        # pad or trim to match
        names = (names + [f"x{i+1}" for i in range(len(names), n_inputs)])[:n_inputs]
    return names


def _normalize_xlag(xlag, n_inputs: int) -> List[List[int]]:
    """Normalize xlag into a nested list of per-input lag lists.

    Mirrors the ordering in `information_matrix._create_lagged_x`.
    """
    if isinstance(xlag, int):
        return [list(range(1, xlag + 1))] if n_inputs == 1 else [[xlag]]

    # xlag is a list: could be flat or nested
    if n_inputs == 1 and all(isinstance(i, int) for i in xlag):
        return [list(xlag)]

    # nested case: ensure each item is a list
    return [[i] if isinstance(i, int) else list(i) for i in xlag]


def _base_lag_feature_names(
    *, n_inputs: int, xlag, ylag, input_names: Optional[Sequence[str]], output_name: str
) -> List[str]:
    """Names of raw lagged variables in the same order as `lagged_data[:, 1:]`.

    Order: [y(k-1..), ..., then x1(k-..), x2(k-..), ...]
    """
    in_names = _ensure_input_names(n_inputs, input_names)
    ylags = _process_ylag(ylag)
    xlags_nested = _normalize_xlag(xlag, n_inputs)

    names: List[str] = []
    # y lags first
    names.extend([f"{output_name}(k-{lag})" for lag in ylags])

    # inputs
    for i in range(n_inputs):
        xi = in_names[i]
        names.extend([f"{xi}(k-{lag})" for lag in xlags_nested[i]])

    return names


def _legendre_like_names(
    *,
    basis_name: str,
    n_inputs: int,
    xlag,
    ylag,
    degree: int,
    include_bias: bool,
    ensemble: bool,
    input_names: Optional[Sequence[str]],
    output_name: str,
) -> List[str]:
    """Return names for Legendre/Hermite/Laguerre/Bernstein-style classes.

    Real ordering in *fit*:
        data := lagged_data[max_lag:, 1:]  (lags only; no intercept)
        expansions (remove P0) => degrees 1..degree per original column
        if include_bias: prepend bias column (1)
        if ensemble: prepend original data columns before bias/expansions

    We reproduce exactly this ordering so indices map correctly to theta.
    """
    base = _base_lag_feature_names(
        n_inputs=n_inputs,
        xlag=xlag,
        ylag=ylag,
        input_names=input_names,
        output_name=output_name,
    )
    sym = {
        "Legendre": "P",
        "Hermite": "H",
        "HermiteNormalized": "He",
        "Laguerre": "L",
        "Bernstein": "B",
    }.get(basis_name, basis_name)

    expansions: List[str] = []
    for var in base:
        for d in range(1, degree + 1):
            token = "B" if sym == "B" else sym
            expansions.append(f"{token}{d}({var})")

    names: List[str] = []
    # ensemble first (original data columns)
    if ensemble:
        names.extend(base)
    # bias next (if any)
    if include_bias:
        names.append("1")
    # then expansions
    names.extend(expansions)
    return names


def _fourier_names(
    *,
    n_inputs: int,
    xlag,
    ylag,
    degree: int,
    n_harmonics: int,
    ensemble: bool,
    input_names: Optional[Sequence[str]],
    output_name: str,
) -> List[str]:
    """Return column names for Fourier basis.

    Column order in Fourier.fit:
        - If degree > 1: `data` is Polynomial().fit(...)[ :, 1:]
            (monomials without intercept)
    - Else: `data` is lagged_data[max_lag:, 1:] (raw lags)
    - For each `data` column (left-to-right), append cos/sin for h=1..n_harmonics
    - If ensemble=True, prepend the original `data` columns first
    """
    # Build base data column names
    if degree and degree > 1:
        # Name monomials generated by Polynomial.fit over lagged_data
        base = _polynomial_monomial_names(
            n_inputs=n_inputs,
            xlag=xlag,
            ylag=ylag,
            degree=degree,
            input_names=input_names,
            output_name=output_name,
            drop_intercept=True,
        )
    else:
        base = _base_lag_feature_names(
            n_inputs=n_inputs,
            xlag=xlag,
            ylag=ylag,
            input_names=input_names,
            output_name=output_name,
        )

    names: List[str] = []
    if ensemble:
        names.extend(base)

    for var in base:
        for h in range(1, n_harmonics + 1):
            names.append(f"cos({h}路{var})")
            names.append(f"sin({h}路{var})")
    return names


def _polynomial_monomial_names(
    *,
    n_inputs: int,
    xlag,
    ylag,
    degree: int,
    input_names: Optional[Sequence[str]],
    output_name: str,
    drop_intercept: bool = False,
) -> List[str]:
    """Recreate monomial names in the order Polynomial.fit would generate.

    This mirrors Polynomial.fit combinations over `lagged_data` columns.
    """
    in_names = _ensure_input_names(n_inputs, input_names)
    ylags = _process_ylag(ylag)
    xlags_nested = _normalize_xlag(xlag, n_inputs)

    # Column 0 is constant 1, then y lags, then x lags in order
    base_cols: List[str] = ["1"]
    base_cols.extend([f"{output_name}(k-{lag})" for lag in ylags])
    for i in range(n_inputs):
        xi = in_names[i]
        base_cols.extend([f"{xi}(k-{lag})" for lag in xlags_nested[i]])

    combos = list(combinations_with_replacement(range(len(base_cols)), degree))

    def idx_row_to_name(idx_row: Sequence[int]) -> str:
        counts = Counter(idx_row)
        parts: List[str] = []
        for idx in sorted(counts.keys()):
            if idx == 0:
                # skip explicit "1" factor
                continue
            var = base_cols[idx]
            exp = counts[idx]
            parts.append(var + (f"^{exp}" if exp > 1 else ""))
        return "".join(parts) if parts else "1"

    names = [idx_row_to_name(row) for row in combos]
    if drop_intercept:
        # Mirror Fourier.fit slicing [:, 1:]
        return names[1:]
    return names


def _bilinear_names(
    *,
    n_inputs: int,
    xlag,
    ylag,
    degree: int,
    input_names: Optional[Sequence[str]],
    output_name: str,
) -> List[str]:
    """Reconstruct bilinear feature names matching Bilinear.fit ordering.

    Bilinear.fit:
        1. Builds combination_list over full lagged matrix columns (with intercept)
        2. Removes combinations containing only y or only x-block of a single input
        3. Keeps remaining (mixed) combinations

    We replicate the same steps here to ensure indices align.
    """
    # Base columns (with intercept) replicating polynomial style
    ylags = _process_ylag(ylag)
    in_names = _ensure_input_names(n_inputs, input_names)
    xlags_nested = _normalize_xlag(xlag, n_inputs)

    base_cols: List[str] = ["1"]
    base_cols.extend([f"{output_name}(k-{lag})" for lag in ylags])
    x_block_indices: List[List[int]] = []
    cursor = 1 + len(ylags)
    for i, lags in enumerate(xlags_nested):
        block = list(range(cursor, cursor + len(lags)))
        x_block_indices.append(block)
        base_cols.extend([f"{in_names[i]}(k-{lag})" for lag in lags])
        cursor += len(lags)

    # Generate all combinations with replacement
    all_idx = list(range(len(base_cols)))
    combos = list(combinations_with_replacement(all_idx, degree))

    y_indices = list(range(1, 1 + len(ylags)))

    def is_pure_y(cmb):
        return cmb and all(i in y_indices for i in cmb)

    def is_pure_single_x(cmb):
        if not cmb:
            return False
        for block in x_block_indices:
            if all(i in block for i in cmb):
                return True
        return False

    filtered = [c for c in combos if not (is_pure_y(c) or is_pure_single_x(c))]

    def combo_to_name(cmb):
        counts = Counter(cmb)
        parts: List[str] = []
        for idx in sorted(counts.keys()):
            if idx == 0:
                continue  # skip implicit intercept
            var = base_cols[idx]
            exp = counts[idx]
            parts.append(var + (f"^{exp}" if exp > 1 else ""))
        return "".join(parts) if parts else "1"

    return [combo_to_name(c) for c in filtered]


Renderer = Callable[[object, Optional[Sequence[str]], str], List[str]]


def _render_polynomial(model, input_names, output_name):
    n_inputs = getattr(model, "n_inputs", None)
    if n_inputs is None:
        xlag_attr = getattr(model, "xlag", 1)
        n_inputs = 1 if isinstance(xlag_attr, int) else len(xlag_attr)
    return _polynomial_monomial_names(
        n_inputs=n_inputs,
        xlag=getattr(model, "xlag", 1),
        ylag=getattr(model, "ylag", 1),
        degree=getattr(getattr(model, "basis_function", object()), "degree", 1) or 1,
        input_names=input_names,
        output_name=output_name,
        drop_intercept=False,
    )


def _render_fourier(model, input_names, output_name):
    bf = model.basis_function
    n_inputs = getattr(model, "n_inputs", None)
    if n_inputs is None:
        xlag_attr = getattr(model, "xlag", 1)
        n_inputs = 1 if isinstance(xlag_attr, int) else len(xlag_attr)
    return _fourier_names(
        n_inputs=n_inputs,
        xlag=getattr(model, "xlag", 1),
        ylag=getattr(model, "ylag", 1),
        degree=getattr(bf, "degree", 1) or 1,
        n_harmonics=getattr(bf, "n", 1) or 1,
        ensemble=bool(getattr(bf, "ensemble", False)),
        input_names=input_names,
        output_name=output_name,
    )


def _render_legendre_like(model, input_names, output_name):
    bf = model.basis_function
    n_inputs = getattr(model, "n_inputs", None)
    if n_inputs is None:
        xlag_attr = getattr(model, "xlag", 1)
        n_inputs = 1 if isinstance(xlag_attr, int) else len(xlag_attr)
    return _legendre_like_names(
        basis_name=bf.__class__.__name__,
        n_inputs=n_inputs,
        xlag=getattr(model, "xlag", 1),
        ylag=getattr(model, "ylag", 1),
        degree=getattr(bf, "degree", 1) or 1,
        include_bias=bool(getattr(bf, "include_bias", True)),
        ensemble=bool(getattr(bf, "ensemble", False)),
        input_names=input_names,
        output_name=output_name,
    )


def _render_bilinear(model, input_names, output_name):
    bf = model.basis_function
    n_inputs = getattr(model, "n_inputs", None)
    if n_inputs is None:
        xlag_attr = getattr(model, "xlag", 1)
        n_inputs = 1 if isinstance(xlag_attr, int) else len(xlag_attr)
    return _bilinear_names(
        n_inputs=n_inputs,
        xlag=getattr(model, "xlag", 1),
        ylag=getattr(model, "ylag", 1),
        degree=getattr(bf, "degree", 2) or 2,
        input_names=input_names,
        output_name=output_name,
    )


def _render_fallback(model, input_names, output_name):
    # Basic lag names; if degree>1 append synthetic powers.
    # Emit a one-time warning for unknown / unregistered basis class.
    bf = getattr(model, "basis_function", None)
    degree = getattr(bf, "degree", 1) if bf is not None else 1
    if bf is not None:
        cls_name = bf.__class__.__name__
        if cls_name not in RendererRegistry and cls_name not in _warned_unknown_bases:
            warnings.warn(
                (
                    "Equation formatter fallback used for unregistered basis '"
                    f"{cls_name}'. "
                    "Rendered feature names may be approximate. "
                    "Register a renderer via register_equation_renderer "
                    "for exact names."
                ),
                UserWarning,
                stacklevel=2,
            )
            _warned_unknown_bases.add(cls_name)
    n_inputs = getattr(model, "n_inputs", None)
    if n_inputs is None:
        xlag_attr = getattr(model, "xlag", 1)
        n_inputs = 1 if isinstance(xlag_attr, int) else len(xlag_attr)
    base = _base_lag_feature_names(
        n_inputs=n_inputs,
        xlag=getattr(model, "xlag", 1),
        ylag=getattr(model, "ylag", 1),
        input_names=input_names,
        output_name=output_name,
    )
    if degree and degree > 1:
        ext = [f"{b}^{d}" for b in base for d in range(2, degree + 1)]
        return base + ext
    return base


RendererRegistry: Dict[str, Renderer] = {
    "Polynomial": _render_polynomial,
    "Fourier": _render_fourier,
    "Legendre": _render_legendre_like,
    "Hermite": _render_legendre_like,
    "HermiteNormalized": _render_legendre_like,
    "Laguerre": _render_legendre_like,
    "Bernstein": _render_legendre_like,
    "Bilinear": _render_bilinear,
}

_warned_unknown_bases: set[str] = set()


def register_equation_renderer(
    name: str, renderer: Renderer, *, overwrite: bool = False
) -> None:
    """Register or replace a custom equation renderer.

    Parameters
    ----------
    name : str
        Basis function class name (basis_function.__class__.__name__).
    renderer : callable
    Function(model, input_names, output_name) -> List[str] with ordered
    feature names.
    overwrite : bool, default False
        If False and a renderer already exists for this name, raises ValueError.
    """
    if not name or not isinstance(name, str):
        raise ValueError("'name' must be a non-empty string")
    if not callable(renderer):
        raise ValueError("'renderer' must be callable")
    if name in RendererRegistry and not overwrite:
        raise ValueError(
            f"Renderer for '{name}' already registered. Use overwrite=True to replace."
        )
    RendererRegistry[name] = renderer
    _warned_unknown_bases.discard(name)


def _is_polynomial_model(model) -> bool:
    bf = getattr(model, "basis_function", None)
    return (
        getattr(bf, "__class__", None) is not None
        and bf.__class__.__name__ == "Polynomial"
    )


def results_general(
    model,
    *,
    input_names: Optional[Sequence[str]] = None,
    output_name: str = "y",
) -> List[EquationItem]:
    """Return list of (feature name, coefficient) for the model's selected terms.

    Steps:
        1. Retrieve theta
        2. Obtain renderer by basis_function class name (registry)
        3. Build full name list
        4. Map pivv -> names (or full order if pivv None)
    """
    theta = getattr(model, "theta", None)
    if theta is None:
        return []
    theta_arr = np.array(theta).reshape(-1)
    if theta_arr.size == 0:
        return []

    bf = getattr(model, "basis_function", None)
    class_name = getattr(bf, "__class__", type("", (), {})).__name__ if bf else ""
    renderer = RendererRegistry.get(class_name, _render_fallback)
    names = renderer(model, input_names, output_name)

    pivv = getattr(model, "pivv", None)
    items: List[EquationItem] = []
    if pivv is None:
        size = min(len(names), theta_arr.size)
        return [
            EquationItem(name=names[i], coef=float(theta_arr[i])) for i in range(size)
        ]
    for i, col_idx in enumerate(np.array(pivv).reshape(-1)[: theta_arr.size]):
        idx = int(col_idx)
        if 0 <= idx < len(names):
            items.append(EquationItem(name=names[idx], coef=float(theta_arr[i])))
        else:
            items.append(EquationItem(name=f"f_{idx}", coef=float(theta_arr[i])))
    return items


def format_equation(
    model,
    *,
    input_names: Optional[Sequence[str]] = None,
    output_name: str = "y",
    style: str = "text",  # "text" or "latex"
    coef_format: str = ".6g",
    first_sign: bool = False,
    ascii_mode: bool = False,
) -> str:
    """Format model as equation string.

    Parameters
    ----------
    first_sign : bool
        If False (default) suppress leading '+' for first positive term.
    ascii_mode : bool
        If True use '*' instead of '路' middle dot.
    """
    items = results_general(model, input_names=input_names, output_name=output_name)
    if not items:
        return ""

    mult = "*" if ascii_mode or style == "latex" else "路"
    lhs = f"{output_name}(k)"
    rhs_parts: List[str] = []
    for i, it in enumerate(items):
        coef_txt = _format_coefficient(
            it.coef,
            coef_format=coef_format,
            leading=i > 0,
            first_sign=first_sign,
        )
        if style == "latex":
            rhs_parts.append(f"{coef_txt}\\,{it.name}")
        else:
            rhs_parts.append(f"{coef_txt}{mult}{it.name}")
    rhs = " ".join(rhs_parts)
    return f"{lhs} = {rhs}"
